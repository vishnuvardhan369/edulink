<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EduLink WebRTC Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .controls {
            margin: 20px 0;
            text-align: center;
        }
        input, button {
            padding: 10px;
            margin: 5px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .videos {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        video {
            width: 300px;
            height: 200px;
            background: #000;
            border-radius: 8px;
        }
        .status {
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            margin: 10px 0;
        }
        .media-controls {
            text-align: center;
            margin: 15px 0;
        }
        .media-controls button {
            margin: 0 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ§ª EduLink WebRTC Test</h1>
        
        <div class="controls">
            <input type="text" id="roomId" placeholder="Enter Room ID" value="test-room-123">
            <button id="joinBtn">Join Call</button>
            <button id="leaveBtn" disabled>Leave Call</button>
        </div>
        
        <div class="media-controls">
            <button id="toggleVideo">Enable Video</button>
            <button id="toggleAudio">Mute Audio</button>
            <button id="screenShare" disabled>Share Screen</button>
        </div>
        
        <div class="status" id="status">Not connected</div>
        
        <div class="videos">
            <div>
                <h3>Local Video</h3>
                <video id="localVideo" autoplay muted></video>
            </div>
            <div>
                <h3>Remote Video</h3>
                <video id="remoteVideo" autoplay></video>
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        let localStream;
        const peerConnections = {};
        let roomId;
        let isVideoEnabled = false;
        let isAudioEnabled = true;
        let isScreenSharing = false;

        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' }
            ]
        };

        const joinBtn = document.getElementById('joinBtn');
        const leaveBtn = document.getElementById('leaveBtn');
        const toggleVideoBtn = document.getElementById('toggleVideo');
        const toggleAudioBtn = document.getElementById('toggleAudio');
        const screenShareBtn = document.getElementById('screenShare');
        const roomIdInput = document.getElementById('roomId');
        const statusElement = document.getElementById('status');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');

        joinBtn.addEventListener('click', joinCall);
        leaveBtn.addEventListener('click', leaveCall);
        toggleVideoBtn.addEventListener('click', toggleVideo);
        toggleAudioBtn.addEventListener('click', toggleAudio);
        screenShareBtn.addEventListener('click', toggleScreenShare);

        async function joinCall() {
            roomId = roomIdInput.value.trim();
            if (!roomId) {
                alert('Please enter a room ID');
                return;
            }

            try {
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: true, 
                    video: isVideoEnabled 
                });
                
                localVideo.srcObject = localStream;
                
                socket.emit('join-room', roomId);
                statusElement.textContent = `Connected to room: ${roomId}`;
                
                joinBtn.disabled = true;
                leaveBtn.disabled = false;
                roomIdInput.disabled = true;
                toggleVideoBtn.disabled = false;
                toggleAudioBtn.disabled = false;
                screenShareBtn.disabled = false;

            } catch (error) {
                console.error('Error accessing media devices:', error);
                alert('Could not access camera/microphone');
            }
        }

        function leaveCall() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            
            for (const userId in peerConnections) {
                if (peerConnections[userId]) {
                    peerConnections[userId].close();
                    delete peerConnections[userId];
                }
            }
            
            statusElement.textContent = 'Not connected';
            joinBtn.disabled = false;
            leaveBtn.disabled = true;
            roomIdInput.disabled = false;
            toggleVideoBtn.disabled = true;
            toggleAudioBtn.disabled = true;
            screenShareBtn.disabled = true;
            
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
        }

        async function toggleVideo() {
            isVideoEnabled = !isVideoEnabled;
            toggleVideoBtn.textContent = isVideoEnabled ? 'Disable Video' : 'Enable Video';

            if (localStream) {
                if (isVideoEnabled) {
                    try {
                        const videoStream = await navigator.mediaDevices.getUserMedia({ video: true });
                        const videoTrack = videoStream.getVideoTracks()[0];
                        localStream.addTrack(videoTrack);
                        localVideo.srcObject = new MediaStream(localStream.getTracks());

                        for (const userId in peerConnections) {
                            const peerConnection = peerConnections[userId];
                            const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
                            if (sender) {
                                sender.replaceTrack(videoTrack);
                            } else {
                                peerConnection.addTrack(videoTrack, localStream);
                            }
                        }
                    } catch (error) {
                        console.error('Error enabling video:', error);
                        isVideoEnabled = false;
                        toggleVideoBtn.textContent = 'Enable Video';
                    }
                } else {
                    const videoTrack = localStream.getVideoTracks()[0];
                    if (videoTrack) {
                        videoTrack.stop();
                        localStream.removeTrack(videoTrack);
                        localVideo.srcObject = new MediaStream(localStream.getTracks());
                    }
                }
            }
        }

        function toggleAudio() {
            isAudioEnabled = !isAudioEnabled;
            
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) {
                    audioTrack.enabled = isAudioEnabled;
                }
            }
            
            toggleAudioBtn.textContent = isAudioEnabled ? 'Mute Audio' : 'Unmute Audio';
        }

        async function toggleScreenShare() {
            if (!isScreenSharing) {
                try {
                    const screenStream = await navigator.mediaDevices.getDisplayMedia({
                        video: true,
                        audio: true
                    });
                    
                    const screenTrack = screenStream.getVideoTracks()[0];
                    const currentVideoTrack = localStream.getVideoTracks()[0];
                    
                    if (currentVideoTrack) {
                        currentVideoTrack.stop();
                        localStream.removeTrack(currentVideoTrack);
                    }
                    
                    localStream.addTrack(screenTrack);
                    localVideo.srcObject = new MediaStream(localStream.getTracks());
                    
                    for (const userId in peerConnections) {
                        const peerConnection = peerConnections[userId];
                        const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
                        if (sender) {
                            await sender.replaceTrack(screenTrack);
                        } else {
                            peerConnection.addTrack(screenTrack, localStream);
                        }
                    }
                    
                    isScreenSharing = true;
                    screenShareBtn.textContent = 'Stop Sharing';
                    toggleVideoBtn.disabled = true;
                    
                    screenTrack.onended = () => {
                        stopScreenShare();
                    };
                    
                } catch (error) {
                    console.error('Error starting screen share:', error);
                }
            } else {
                stopScreenShare();
            }
        }

        async function stopScreenShare() {
            if (isScreenSharing) {
                const screenTrack = localStream.getVideoTracks()[0];
                if (screenTrack) {
                    screenTrack.stop();
                    localStream.removeTrack(screenTrack);
                }
                
                if (isVideoEnabled) {
                    try {
                        const videoStream = await navigator.mediaDevices.getUserMedia({ video: true });
                        const newVideoTrack = videoStream.getVideoTracks()[0];
                        localStream.addTrack(newVideoTrack);
                        
                        for (const userId in peerConnections) {
                            const peerConnection = peerConnections[userId];
                            const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
                            if (sender) {
                                await sender.replaceTrack(newVideoTrack);
                            }
                        }
                    } catch (error) {
                        console.error('Error restoring camera:', error);
                        isVideoEnabled = false;
                        toggleVideoBtn.textContent = 'Enable Video';
                    }
                }
                
                localVideo.srcObject = new MediaStream(localStream.getTracks());
                isScreenSharing = false;
                screenShareBtn.textContent = 'Share Screen';
                toggleVideoBtn.disabled = false;
            }
        }

        // Socket event handlers
        socket.on('user-connected', async (userId) => {
            console.log('User connected:', userId);
            
            const peerConnection = new RTCPeerConnection(configuration);
            peerConnections[userId] = peerConnection;

            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            peerConnection.ontrack = (event) => {
                const [remoteStream] = event.streams;
                remoteVideo.srcObject = remoteStream;
            };

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('ice-candidate', {
                        candidate: event.candidate,
                        target: userId
                    });
                }
            };

            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            socket.emit('offer', { offer, target: userId });
        });

        socket.on('offer', async (data) => {
            const { offer, caller } = data;
            console.log('Received offer from:', caller);
            
            const peerConnection = new RTCPeerConnection(configuration);
            peerConnections[caller] = peerConnection;

            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            peerConnection.ontrack = (event) => {
                const [remoteStream] = event.streams;
                remoteVideo.srcObject = remoteStream;
            };

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('ice-candidate', {
                        candidate: event.candidate,
                        target: caller
                    });
                }
            };

            await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            
            socket.emit('answer', { answer, target: caller });
        });

        socket.on('answer', async (data) => {
            const { answer, answerer } = data;
            console.log('Received answer from:', answerer);
            
            const peerConnection = peerConnections[answerer];
            if (peerConnection) {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
            }
        });

        socket.on('ice-candidate', async (data) => {
            const { candidate, from } = data;
            console.log('Received ICE candidate from:', from);
            
            const peerConnection = peerConnections[from];
            if (peerConnection) {
                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            }
        });

        socket.on('user-disconnected', (userId) => {
            console.log('User disconnected:', userId);
            
            if (peerConnections[userId]) {
                peerConnections[userId].close();
                delete peerConnections[userId];
            }
            
            remoteVideo.srcObject = null;
        });

        console.log('âœ… WebRTC test page loaded successfully');
    </script>
</body>
</html>